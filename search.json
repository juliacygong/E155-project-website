[
  {
    "objectID": "mcu.html",
    "href": "mcu.html",
    "title": "MCU Design",
    "section": "",
    "text": "The main purpose of the MCU in this project, STM32L432KC, is to serve as the front-end data acquisition system for the music transcriber. Utilizing a hardware timer triggered Analog-to-Digital Converter (ADC) with double buffers, the system samples analog audio signals, convert them to digital signals, and transmit data packets to the FPGA via SPI. After setting up the required peripherals, the MCU operates in two states, idle and sampling, where the sampling state is triggered and stopped by a button press on the user’s end."
  },
  {
    "objectID": "mcu.html#overview",
    "href": "mcu.html#overview",
    "title": "MCU Design",
    "section": "",
    "text": "The main purpose of the MCU in this project, STM32L432KC, is to serve as the front-end data acquisition system for the music transcriber. Utilizing a hardware timer triggered Analog-to-Digital Converter (ADC) with double buffers, the system samples analog audio signals, convert them to digital signals, and transmit data packets to the FPGA via SPI. After setting up the required peripherals, the MCU operates in two states, idle and sampling, where the sampling state is triggered and stopped by a button press on the user’s end."
  },
  {
    "objectID": "mcu.html#data-acquisition-architecture",
    "href": "mcu.html#data-acquisition-architecture",
    "title": "MCU Design",
    "section": "Data Acquisition Architecture",
    "text": "Data Acquisition Architecture\n\nADC Initialization & Interrupts\nThe ADC is configured for non-continuous mode and triggered externally by the hardware timer TIM6. The FFT algorithm assumes that the time difference between every single sample is identical. In continuous mode, the ADC samples continuously, starting the next conversion immediately as the previous one finished. Therefore, the sampling time is dependent on internal ADC settings, such as the ADC clock and calibration cycles, making it hard to ensure that the time between samples stay constant and to obtain the sampling frequency. However, by using the non-continuous mode and a timer, the MCU can be set to a desired sampling rate.\nThe trigger source of the ADC, TIM6, is set to toggle at a frequency of 5 kHz. As the ADC is set to trigger on the rising edge of this timer using Timer 6 TRGO (EXTSEL = 13), a sampling rate of 5 kHz. One important factor in FFT is the frequency resolution, which can be calculated as:\n\\[\nResolution = \\frac{Sampling Rate}{FFT Size}\n\\]\nGiven that the system uses a 512-point FFT, a higher sampling rate, despite providing more resolution to the original sound signal, would in fact decrease the accuracy of the FFT results. On the other hand, by the Nyquist-Shannon sampling theorem, the sampling rate would limit the highest frequency detectable to be half of the sampling rate. The high C (C6), which is a very high soprano note and hardly appears in pop music melodies, is approximately 1046 Hz. Balancing between the highest frequency detectable, number of data points per period, and the FFT resolution, the sampling rate of the system was decided as 5 kHz.\nThe resolution of the ADC samples are set to 8-bit instead of the normal 12-bit. The complexity of the math logic gates scales with bit depth on the FPGA. While the iCE40UP5K has DSP blocks, the number of bits of addition and multiplication results quickly grows, and may eventually overflow. Adding more bits to the logics in FPGA was not practical due to the restrictions of resource in the FPGA. 8-bit data would also perfectly fit into one SPI transmission without any extra bits, making the logic of receiving data on the FPGA easier.\n\n\nDouble Buffering\nTo prevent data loss during the time it takes to transmit data to the FPGA, a double-buffereing method was implemented. Each buffer, buffer0 and buffer1, are set to be 512-byte arrays. fillBuffer acts as a pointer to the array currently being written to by the ADC, and sendBuffer points to the array currently stable and ready for SPI transmission. When the ADC fills fillBuffer with 512 samples, the interrupt handler swaps the pointers and raises a bufferReady flag. The main loop detects this flag and begins transmitting sendBuffer via SPI while the ADC immediately begins writing to the new fillBuffer in the background.\nOn the other hand, while the STM32 supports Direct Memory Access (DMA), the CPU overhead for processing 5 kHz interrupts is negligible, making the complexity of configuring DMA unnecessary for performance. Additionally, using a standard interrupt allows for simpler, explicit control over the double-buffer pointer swapping logic and easier real-time debugging through GPIO toggles."
  },
  {
    "objectID": "mcu.html#spi-communication",
    "href": "mcu.html#spi-communication",
    "title": "MCU Design",
    "section": "SPI Communication",
    "text": "SPI Communication\nThe communication between the MCU and the FPGA is established using the SPI, where the MCU acts as the SPI Master. To ensure synchronization with the FPGA, the Chip Select (CS) line is toggled manually for every byte transmitted. This provides a clear signal for each new “sample” which the FPGA receives.\nA logic analyzer result of the SPI transferring the microphone signal is shown here:\n\n\n\nSPI logic analyzer result"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Live Music Transcriber",
    "section": "",
    "text": "This project aims to take in sound inputs, whether using a keyboard, any instruments, or someone signing, transcribe the sound onto a score in real-time with a given bpm, and play back the input melody. An FPGA will be used as the main calculation and display engine, using Fast Fourier Transform (FFT) to handle frequency analysis and driving a VGA display. A MCU will be used for interfacing the audio inputs and outputs.\nOn the hardware level, an analog microphone will take in sounds, where the MCU will convert them into digital signals using ADC and send the converted signals to the FPGA. The MCU will then send the digital signals to the FPGA using SPI. Then, the FPGA will use FFT to extract the frequency and duration of the note inputted. The array of notes will then be used by the FPGA to calculate the pixels for displaying the score on a VGA display. This array of notes, after transcription ends, will be sent to the MCU through SPI to generate the playback audio. The user should be able to control the music transcription and play back audio with a hardware components such as a switch or a button, and control the volume with a potentiometer."
  },
  {
    "objectID": "index.html#project-abstract",
    "href": "index.html#project-abstract",
    "title": "Live Music Transcriber",
    "section": "",
    "text": "This project aims to take in sound inputs, whether using a keyboard, any instruments, or someone signing, transcribe the sound onto a score in real-time with a given bpm, and play back the input melody. An FPGA will be used as the main calculation and display engine, using Fast Fourier Transform (FFT) to handle frequency analysis and driving a VGA display. A MCU will be used for interfacing the audio inputs and outputs.\nOn the hardware level, an analog microphone will take in sounds, where the MCU will convert them into digital signals using ADC and send the converted signals to the FPGA. The MCU will then send the digital signals to the FPGA using SPI. Then, the FPGA will use FFT to extract the frequency and duration of the note inputted. The array of notes will then be used by the FPGA to calculate the pixels for displaying the score on a VGA display. This array of notes, after transcription ends, will be sent to the MCU through SPI to generate the playback audio. The user should be able to control the music transcription and play back audio with a hardware components such as a switch or a button, and control the volume with a potentiometer."
  },
  {
    "objectID": "index.html#project-motivation",
    "href": "index.html#project-motivation",
    "title": "Live Music Transcriber",
    "section": "Project Motivation",
    "text": "Project Motivation\nBoth of us are interested in digital design and audio processing, so we wanted to leverage the FPGA’s fast computational capabilites to process sound for our project. Due to the importance and wide applications of the FFT, we wanted to design and integrate FFT in hardware. We chose VGA to display our output because we wanted to accurately depict a music score, which required a higher pixel resolution."
  },
  {
    "objectID": "index.html#system-block-diagram",
    "href": "index.html#system-block-diagram",
    "title": "Live Music Transcriber",
    "section": "System Block Diagram",
    "text": "System Block Diagram\n\nThe system block diagram shows the flow of our design, starting with an input from a microphone which is sampled by the MCU’s internal ADC. The MCU’s ADC output is sent over to the FPGA using SPI. The music score and notes are output from FPGA to the VGA monitor."
  },
  {
    "objectID": "index.html#note-display",
    "href": "index.html#note-display",
    "title": "Live Music Transcriber",
    "section": "Note Display",
    "text": "Note Display\nVideo"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Live Music Transcriber",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe would like to thank Prof Spencer for all advice in debugging our system and challenging us to build this complex project. We would also like to thank Xavier for giving us VGA monitors to use as well as the grutors Kavi, Troy, and Vikram for all their helpful debugging tips.\nLastly we would like to give a shoutout to our friends in Microps who accompanied us during late nights that transitioned into early mornings in the lab and offered support and help throughout the process!"
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Results",
    "section": "",
    "text": "The original proposed specifications are listed here. Note that the playback specs are deleted after consulting Prof. Spencer on downscaling the project.\n\n\n\nUser can stop and start transcription using physical hardware (e.g. switch/button)\nSystem converts analog microphone signals into digital\nUses FFT to extract clear signal from input\nSystem calculates input frequency and rounds to the nearest half note (e.g. A3#, C4)\nSystem able to detect duration accurate to 1/16 beat at the given BPM\n\n\n\n\n\nDisplay updates at &gt; 24 Hz\nNote durations are displayed for 120 BPM\nNotes are displayed on VGA monitor ~75 ms after note is released\nPlayback audio resembles the input\nPlayback audio uses an audio codec so that output sound is not square wave\nUser can control the volume of playback audio\nUser can control when to playback the transcribed audio (e.g. switch/button), but can only play the audio when transcription is stopped"
  },
  {
    "objectID": "results.html#project-specifications-list",
    "href": "results.html#project-specifications-list",
    "title": "Results",
    "section": "",
    "text": "The original proposed specifications are listed here. Note that the playback specs are deleted after consulting Prof. Spencer on downscaling the project.\n\n\n\nUser can stop and start transcription using physical hardware (e.g. switch/button)\nSystem converts analog microphone signals into digital\nUses FFT to extract clear signal from input\nSystem calculates input frequency and rounds to the nearest half note (e.g. A3#, C4)\nSystem able to detect duration accurate to 1/16 beat at the given BPM\n\n\n\n\n\nDisplay updates at &gt; 24 Hz\nNote durations are displayed for 120 BPM\nNotes are displayed on VGA monitor ~75 ms after note is released\nPlayback audio resembles the input\nPlayback audio uses an audio codec so that output sound is not square wave\nUser can control the volume of playback audio\nUser can control when to playback the transcribed audio (e.g. switch/button), but can only play the audio when transcription is stopped"
  },
  {
    "objectID": "results.html#specifications-result",
    "href": "results.html#specifications-result",
    "title": "Results",
    "section": "Specifications Result",
    "text": "Specifications Result\nHere, we will explain the specs that are met by the project:\n\nUser can stop and start transcription using physical hardware (e.g. switch/button)\nThe system includes a button which signals the MCU to start and stop transcribing.\nSystem converts analog microphone signals into digital\nThe ADC on the MCU worked, and we were able to obtain digital signals from the SPI. A logic analyzer result of the SPI transferring microphone signal is shown here:\n\n\n\nSPI logic analyzer result\n\n\nThe mosi signals mostly sits around 80 because the microphone’s quinscient voltage sits at have the voltage supplied.\nUses FFT to extract clear signal from input\nWe were able to use FFT to extract signals and output notes detected. This is especially successful in simulation. In hardware, the system experiences instability due to the amount of environmental noises.\nSystem calculates input frequency and rounds to the nearest half note (e.g. A3#, C4)\nBuilding on the previous spec, the FFT was able to clearly distinguish note, octave, and sharp in simulation. In hardware, it was also able to output certain notes.\nSystem able to detect duration accurate to 1/16 beat at the given BPM\nThe constraint of the system had to be changed to 1/2 of the beat due to the downscale of sampling rate.\nDisplay updates at &gt; 24 Hz\nThe VGA is refreshing at a rate of 60 Hz.\nNote durations are displayed for 120 BPM\nDue to the limited memory on our FPGA, we did not have enough memory to store 16 bits and sample at the desired frequency to capture 8th notes at 120BPM. To work with the amount of memory that we had, we decided to lower the resolution of the inputs to 8 bits so that we could calculate whole number k values that correspond to a note in a two octave range.\nNotes are displayed on VGA monitor ~75 ms after note is released\nOnly notes that fall under a select magnitude will be processed and displayed. The note magnitude was set in place in order to avoid background noise."
  },
  {
    "objectID": "results.html#testbenches",
    "href": "results.html#testbenches",
    "title": "Results",
    "section": "Testbenches",
    "text": "Testbenches\nBefore hardware implementation, the top level module of the FFT, fft_ctrl, was tested with a testbench which takes a generated ideal bitstream data, and input into the system bit by bit. This simulates the SPI transfer action in real hardward, and as shown in the picture, the FFT was able to produce a a stable note D5#, or db in with our defined encodings.\n\n\n\nWaveform of fft_ctrl testbench\n\n\nEach modules within the FFT, including fftfull, addgen, etc., are tested by separate testbench too."
  },
  {
    "objectID": "fpga.html",
    "href": "fpga.html",
    "title": "FPGA Design",
    "section": "",
    "text": "The FPGA was in charge of processing the inputs sampled my the MCU using a 512 point FFT to extract the dominant frequency of each sample as well as displaying the detected notes on a musical score through VGA. The frequency outputs of the FFT was used to decode the corresponding note and duration of each sound input. The note and duration was then passed into the VGA module, which has a pixel resolution of 1024 x 600 and a refresh rate of 60z.\n\n\n\nFigure 1: This image shows the system level block digram of our FPGA design\n\n\n\n\nThe new hardware used was the VGA display. The top module of design would output a vsync and hsync to control the vertical and horizontal location of the beam and 3 - 1 bit color values for red, green, and blue.\nThe entire design uses 19 EBRs, 7 DSPs, and around 3800 LUTs. The entire design runs on a 12MHz clock, which is derived from the HSCOC. The PLL clock roughly doubles the clock to produce a frequency of 25.175MHz to control the VGA dispaly."
  },
  {
    "objectID": "fpga.html#main-fpga-design",
    "href": "fpga.html#main-fpga-design",
    "title": "FPGA Design",
    "section": "",
    "text": "The FPGA was in charge of processing the inputs sampled my the MCU using a 512 point FFT to extract the dominant frequency of each sample as well as displaying the detected notes on a musical score through VGA. The frequency outputs of the FFT was used to decode the corresponding note and duration of each sound input. The note and duration was then passed into the VGA module, which has a pixel resolution of 1024 x 600 and a refresh rate of 60z.\n\n\n\nFigure 1: This image shows the system level block digram of our FPGA design\n\n\n\n\nThe new hardware used was the VGA display. The top module of design would output a vsync and hsync to control the vertical and horizontal location of the beam and 3 - 1 bit color values for red, green, and blue.\nThe entire design uses 19 EBRs, 7 DSPs, and around 3800 LUTs. The entire design runs on a 12MHz clock, which is derived from the HSCOC. The PLL clock roughly doubles the clock to produce a frequency of 25.175MHz to control the VGA dispaly."
  },
  {
    "objectID": "fpga.html#fft-design",
    "href": "fpga.html#fft-design",
    "title": "FPGA Design",
    "section": "FFT Design",
    "text": "FFT Design\nThe Fast Fourier Transform transforms a signal from the time to frequency domain by recursively dividing a discrete fourier transform (DFT) into its odd and even indexed elements. The odd and even DFTs are of size N/2, where N is the size of its non-spit DFT. Using the symmetry and periodicity properties of complex exponentials, the even part corresponds to a half sized DFT and odd part corresponds to a half sized DFT that is multiplied by the twiddle factor (which is complex exponential expressed by \\(W_N\\)).\nThese equations below show the DFT and how the DFT can be split into its even and odd components.\nDFT equation: \\[\nX[k] = \\sum_{n=0}^{N-1} x[n] W_N^{kn}\n\\] DFT equation split into even and odd components: \\[\nX[k]  = \\sum_{m=0}^{\\frac{N}{2}-1} x[2m] W_N^{k(2m)}\n+ \\sum_{m=0}^{\\frac{N}{2}-1} x[2m+1] W_N^{k(2m+1)}\n\\] where \\[\nW_N = e^{-j \\frac{2\\pi}{N}}\n\\]\nUsing Radix-2 decompositions, an N point FFT can be computed through:\n\n\\(\\log_2(N)\\) levels of transforms\nEach transform has \\(N/2\\) butterfly operations\nA total of \\(\\frac{N}{2} \\log_2(N)\\) butterfly operations\n\nWe decided to use a 512 point FFT for higher resolution processing of our microphone inputs. Since N = 512, we would require:\n\n\\(\\log_2(512) = 9\\) levels of transforms\n\\(512/2 = 256\\) butterfly operations\ntotal of \\(\\frac{512}{2} \\log_2(512) = 2304\\) butterfly operations\n\nSince there was a limited amount of memory on our FPGA, we decided to use to calculate FFT on a 16 bit value, with 8 bit real and imaginary values.\nThe FFT design contains an address generation unit, and address control unit, a butterfly unit that houses a complex multiply unit, and 4 RAM blocks.\nThe design begins with loading 512 inputs into RAM0 (ram0_a and ram0_b), and asserts and fft_start signal once all inputs are loaded. The address generation unit then calculates the address of the input values and twiddle factors based on the fft level. The address generation unit calculates each butterfly address pair (a, b) through rotating the indicies, where i is the butterfly level and j is the address index, such that:\n\\[\na = Rotate_5(2j, i)\n\\] \\[\nb = Rotate_5(2j + 1, i)\n\\]\nThe address control unit that asserts commands to perform butterfly operations as well as memory read and write commands. The commands for writing and reading to RAM0 (ram0_a and ram0_b) and RAM1 (ram1_a and ram1_b) switch at every level. Since the system begins by loading the input data into RAM0, all the odd levels will read from RAM0 and write to RAM1 and all the even levels will read from RAM1 and write to RAM0. The proper a and b values are read from memory and input to the butterfly unit, and computes 8 bit real and imaginary values through the following equations\n\\[\nA' = A + B(TW) \\] \\[B' = A - B(TW) \\], where TW is the corresponding twiddle value.\nThe complex butterfly outputs are written back into memory and read the next level. The outputs for the final FFT level are located in RAM0 (ram0_a and ram0_b) and an fft_done flag is asserted once the butterfly values of final level are fully calculated. The outputs of the level are then processed to extract the maximum k value and corresponding dominant frequency of the sample.\nThe memory blocks we were using contains a 2 cycle read delay. Therefore, we had to implement a 2 cycle stall to before calculating the butterfly values. More of the detailed internal stalling and pipelining of the FFT design can be seen in our Github Repository..\n\nFFT Block Diagram\n\n\n\nFigure 2: This image shows the blow diagram for the implementation of the FFT."
  },
  {
    "objectID": "fpga.html#vga-design",
    "href": "fpga.html#vga-design",
    "title": "FPGA Design",
    "section": "VGA Design",
    "text": "VGA Design\nThe VGA design contains several facts that determine how the pixels are displayed on the monitor.\n\nFront Porch: time between end of the visible line and start of horizontal sync pulse allows electron beam to move from end of line to start of next\nHorizontal Sync Pulse: pulse that indicates line done scanning and sto start next\nBack porch: time after horizontal sync pulse and before start of visible line allows electron beam to stabilize before drawing next line\nVisible area: area where line is scanned\n\nThe VGA top module is split into the Phase-Locked Loop (PLL) which generates the proper clock speed for VGA, the VGA control modle, which generates the horizontal and vertical sync signals based on our pixel resolution, and a music score module which draws the score lines, treble clef, and notes.\n\n\n\nFigure 3: This image shows the oscilloscope trace of our PLL clock\n\n\nThe music score module displays the score in a fixed pixel location, so that calculations for the treble clef and note locations are dependent on the score location. The pixel layout for the treble cleff and music notes are stored in a memory file. The treble clef is 40x80 pixels and the notes are each 30x60 pixels. The note memories contain pixels layouts for eighth, quarter, half, and whole notes with and without sharps. The eighth, quarter, and half notes also contain pixel layouts for the stem up and stem down. To calculate the note location, the octave and semitone of each note is compared to the known location for B4 (third line on the score). The stem direction of each note is also calculated in comparison the B4, where notes above B4 will have a downwards stem and those lower on the lower half will have an upwards stem. Additionally, if the note location is calculated as above or below the score, a small ledger will also be included in the note display to properly format the note.\n\nVGA Display\n\n\n\nFigure 4: This image shows the score the monitor.\n\n\n\n\n\nFIgure 5: This image shows notes on the debugging of notes on the monitor"
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "The schematics of the physical system is shown below: \nThe microphone is connected to the PB0, the ADC input pin of the MCU. The MCU is then connected to the FPGA with the SPI outputs, and the FPGA is connected to the VGA using a breakout cord, where sync signals and pixel color signals are then transmitted. The \\(270 \\ohm\\) resistors were implemented since each the color pins of the VGA display allows a voltage of 0.7 V. However, our FPGA pins have an output of 3.3 V. By putting a \\(270 \\ohm\\) resistor in series with the internal \\(75 \\ohm\\) resistor in the VGA, a voltage divider can be created such that the voltage into the VGA is approximately 0.7 V."
  },
  {
    "objectID": "documentation.html#schematics",
    "href": "documentation.html#schematics",
    "title": "Documentation",
    "section": "",
    "text": "The schematics of the physical system is shown below: \nThe microphone is connected to the PB0, the ADC input pin of the MCU. The MCU is then connected to the FPGA with the SPI outputs, and the FPGA is connected to the VGA using a breakout cord, where sync signals and pixel color signals are then transmitted. The \\(270 \\ohm\\) resistors were implemented since each the color pins of the VGA display allows a voltage of 0.7 V. However, our FPGA pins have an output of 3.3 V. By putting a \\(270 \\ohm\\) resistor in series with the internal \\(75 \\ohm\\) resistor in the VGA, a voltage divider can be created such that the voltage into the VGA is approximately 0.7 V."
  },
  {
    "objectID": "documentation.html#new-hardware",
    "href": "documentation.html#new-hardware",
    "title": "Documentation",
    "section": "New Hardware",
    "text": "New Hardware\nTo experiment new hardwares that are not previously used in the class, we chose to implement an analog microphone and a VGA display.\n\nAnalog Microphone\nAn analog microphone is used to take in sound inputs in our system. The analog microphone, MAX4466 from Adafruit, should be supplied with a voltage of 2.4 to 5 V. The microphone can detect sound inputs from 20 to 20k Hz and has an adjustable gain of 25x to 125x. Without filtering, the circuit of this microphone is simple enough, with GND, VCC, and OUT, where the VCC is complient with our 3.3 V breakout board. This allows us to use the ADC function in the MCU that was not previously used in the course\n\n\nVGA Display\nTo display the score, we decided to use a VGA display. The VGA display we used was provided by Xavier, and has 1024 * 600 pixels. The refreshing rate of the VGA was chosen to be 60 Hz, such that there are no obvious frame discontinuity for human eye. A breakout cord was used to send signals between the FPGA and the VGA. More documentations on the design of VGA control can be found in the FPGA page. The VGA allows use to use the primitives, such as PLL_B for its clock, which is something new from the previous labs."
  },
  {
    "objectID": "documentation.html#information-and-references",
    "href": "documentation.html#information-and-references",
    "title": "Documentation",
    "section": "Information and References",
    "text": "Information and References\nDetails on the hardware designs of the MCU and the FPGA can be found in their respective pages.\nThe source code for the project are all included in this Github repository.\n\nHardware References\n\nMCU - STM32L432KC [Reference Manual, Datasheet, Programming Manual]\nFPGA - iCE40UP [Datasheet, Oscillator User Guide]\nMicrophone - MAX4466 [Description Page, Datasheet]\nVGA Connector [Description Page, Universal DE-15 Pin assignments]\nE155 Breakout Board [Schematics, Adapter Schematics]\n\n\n\nOther Reference\n\nG. W. Slade, “The Fast Fourier Transform in Hardware: A Tutorial Based on an FPGA Implementation,” MIT 6.111 Course Handout, Mar. 21, 2013. [Online]. Available: https://web.mit.edu/6.111/www/f2017/handouts/FFTtutorial121102.pdf."
  },
  {
    "objectID": "documentation.html#bill-of-materials",
    "href": "documentation.html#bill-of-materials",
    "title": "Documentation",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\n\n\n\n\n\n\n\n\n\nName\nPart #\nManufacturer\nQuantity\nPrice\n\n\n\n\nMicrophone\nMAX4466\nAdafruit\nx2\n$6.95 * 2 = $13.90\n\n\nAudio Codec\nMAX98357A\nAdafruit\nx1\n$5.95\n\n\nVGA Breakout Cord\n3124\nAdafruit\nx1\n$4.50\n\n\nAudio Jack to Micro USB B converter\n\nPIIHUSW\nx1\n$7.57 (with Amazon Prime)\n\n\nVGA Display\n\n\nx1\nstockroom\n\n\nOp-amp\nMCP601\n\nx1\nstockroom\n\n\nPotentiometer\n\n\nx1\nstockroom\n\n\nSpeaker\n\n\nx1\nstockroom\n\n\nSTM32L432KC Microcontroller\n\nSTMicroelectronics\nx1\nE155 teaching team\n\n\nUPDuino v3.1 ICE40 UP5K FPGA\n\ntinyVision.ai\nx1\nE155 teaching team\n\n\n\n\n\nTotal including shipping + tax\n$46.83 (shipping $12.56 & tax $2.35)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About the Team",
    "section": "",
    "text": "Julia Gong\n\n\n\nLinkedIn | GitHub | Website\n\nJulia Gong is a junior engineering major at Harvey Mudd College. She is interested in digital design and the integration of hardware systems. Outside of engineering, she enjoys creative, hands-on work, including pottery, bead embroidery, painting, and knitting.\n\n\n\nGeorgia Tai\n\n\n\nLinkedIn | GitHub | Website\n\nGeorgia Tai is a junior engineering student at Harvey Mudd College (HMC) with an interest in computer and electrical engineering. Born and raised in Hsinchu, Taiwan, she developed a passion for electrical engineering. Outside of engineering, she enjoys music, drawing, and reading mangas."
  }
]